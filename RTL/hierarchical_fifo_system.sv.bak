// Hierarchical FIFO System - Cascade Architecture
// Three-level buffering with automatic overflow management
module hierarchical_fifo_system #(
    parameter DATA_WIDTH = 16,
    parameter L1_DEPTH = 32,
    parameter L2_DEPTH = 128,
    parameter L3_DEPTH = 512,
    parameter L1_ADDR_WIDTH = $clog2(L1_DEPTH),
    parameter L2_ADDR_WIDTH = $clog2(L2_DEPTH),
    parameter L3_ADDR_WIDTH = $clog2(L3_DEPTH)
)(
    input logic clk,
    input logic rst_n,
    
    input logic [1:0] fifo_mode,
    input logic [7:0] watermark_l1,
    input logic [7:0] watermark_l2,
    input logic [7:0] watermark_l3,
    
    input logic [DATA_WIDTH-1:0] wr_data,
    input logic wr_en,
    output logic wr_full,
    output logic [1:0] wr_level,
    
    output logic [DATA_WIDTH-1:0] rd_data,
    input logic rd_en,
    output logic rd_empty,
    output logic [1:0] rd_level,
    
    output logic [31:0] fifo_status,
    output logic [2:0] level_overflow,
    output logic backpressure_active
);

// L1 FIFO (Primary buffer)
logic [DATA_WIDTH-1:0] l1_mem [L1_DEPTH-1:0];
logic [L1_ADDR_WIDTH:0] l1_wr_ptr, l1_rd_ptr, l1_count;
logic l1_full, l1_empty;

// L2 FIFO (Secondary buffer)
logic [DATA_WIDTH-1:0] l2_mem [L2_DEPTH-1:0];
logic [L2_ADDR_WIDTH:0] l2_wr_ptr, l2_rd_ptr, l2_count;
logic l2_full, l2_empty;

// L3 FIFO (Tertiary buffer)
logic [DATA_WIDTH-1:0] l3_mem [L3_DEPTH-1:0];
logic [L3_ADDR_WIDTH:0] l3_wr_ptr, l3_rd_ptr, l3_count;
logic l3_full, l3_empty;

assign l1_count = l1_wr_ptr - l1_rd_ptr;
assign l1_full = (l1_count >= L1_DEPTH);
assign l1_empty = (l1_count == 0);

assign l2_count = l2_wr_ptr - l2_rd_ptr;
assign l2_full = (l2_count >= L2_DEPTH);
assign l2_empty = (l2_count == 0);

assign l3_count = l3_wr_ptr - l3_rd_ptr;
assign l3_full = (l3_count >= L3_DEPTH);
assign l3_empty = (l3_count == 0);

// Cascade control signals
logic cascade_l1_l2, cascade_l2_l3;
logic restore_l2_l1, restore_l3_l2;

always_comb begin
    cascade_l1_l2 = 0;
    cascade_l2_l3 = 0;
    restore_l2_l1 = 0;
    restore_l3_l2 = 0;
    
    // Cascade L1 to L2 when L1 is full and user is writing
    if (l1_full && !l2_full && (fifo_mode >= 2'b01) && wr_en) begin
        cascade_l1_l2 = 1;
    end
    
    // Cascade L2 to L3 when L2 is full and cascading from L1
    if (l2_full && !l3_full && (fifo_mode == 2'b10) && cascade_l1_l2) begin
        cascade_l2_l3 = 1;
    end
    
    // Restore L2 to L1 when L1 has space and L2 has data (to maintain order)
    if (!l1_full && !l2_empty && (fifo_mode >= 2'b01) && !wr_en && !rd_en) begin
        restore_l2_l1 = 1;
    end
    
    // Restore L3 to L2 when L2 has space and L3 has data
    if (!l2_full && !l3_empty && (fifo_mode == 2'b10) && !cascade_l1_l2 && !restore_l2_l1) begin
        restore_l3_l2 = 1;
    end
end

// L1 FIFO
always_ff @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        l1_wr_ptr <= 0;
        l1_rd_ptr <= 0;
    end else begin
        // Write: user write OR restore from L2
        if (wr_en && !l1_full) begin
            l1_mem[l1_wr_ptr[L1_ADDR_WIDTH-1:0]] <= wr_data;
            l1_wr_ptr <= l1_wr_ptr + 1;
        end else if (restore_l2_l1) begin
            l1_mem[l1_wr_ptr[L1_ADDR_WIDTH-1:0]] <= l2_mem[l2_rd_ptr[L2_ADDR_WIDTH-1:0]];
            l1_wr_ptr <= l1_wr_ptr + 1;
        end
        
        // Read: user read OR cascade to L2
        if (rd_en && !l1_empty) begin
            l1_rd_ptr <= l1_rd_ptr + 1;
        end else if (cascade_l1_l2) begin
            l1_rd_ptr <= l1_rd_ptr + 1;
        end
    end
end

// L2 FIFO
always_ff @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        l2_wr_ptr <= 0;
        l2_rd_ptr <= 0;
    end else begin
        // Write: cascade from L1 OR restore from L3
        if (cascade_l1_l2) begin
            l2_mem[l2_wr_ptr[L2_ADDR_WIDTH-1:0]] <= l1_mem[l1_rd_ptr[L1_ADDR_WIDTH-1:0]];
            l2_wr_ptr <= l2_wr_ptr + 1;
        end else if (restore_l3_l2) begin
            l2_mem[l2_wr_ptr[L2_ADDR_WIDTH-1:0]] <= l3_mem[l3_rd_ptr[L3_ADDR_WIDTH-1:0]];
            l2_wr_ptr <= l2_wr_ptr + 1;
        end
        
        // Read: restore to L1 OR cascade to L3
        if (restore_l2_l1) begin
            l2_rd_ptr <= l2_rd_ptr + 1;
        end else if (cascade_l2_l3) begin
            l2_rd_ptr <= l2_rd_ptr + 1;
        end
    end
end

// L3 FIFO
always_ff @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        l3_wr_ptr <= 0;
        l3_rd_ptr <= 0;
    end else begin
        // Write: cascade from L2
        if (cascade_l2_l3) begin
            l3_mem[l3_wr_ptr[L3_ADDR_WIDTH-1:0]] <= l2_mem[l2_rd_ptr[L2_ADDR_WIDTH-1:0]];
            l3_wr_ptr <= l3_wr_ptr + 1;
        end
        
        // Read: restore to L2
        if (restore_l3_l2) begin
            l3_rd_ptr <= l3_rd_ptr + 1;
        end
    end
end

// Write control
always_comb begin
    case (fifo_mode)
        2'b00: begin
            wr_full = l1_full;
            wr_level = 2'b00;
        end
        2'b01: begin
            wr_full = l1_full && l2_full;
            wr_level = l1_full ? 2'b01 : 2'b00;
        end
        default: begin
            wr_full = l1_full && l2_full && l3_full;
            wr_level = l1_full ? (l2_full ? 2'b10 : 2'b01) : 2'b00;
        end
    endcase
end

// Read control - ALWAYS from L1 only
assign rd_data = l1_mem[l1_rd_ptr[L1_ADDR_WIDTH-1:0]];
assign rd_empty = l1_empty && l2_empty && l3_empty;
assign rd_level = 2'b00;

// Status
assign backpressure_active = (l3_count * 100 >= L3_DEPTH * 90);
assign level_overflow = {l3_full, l2_full, l1_full};
assign fifo_status = {8'h00, l3_count[7:0], l2_count[7:0], l1_count[7:0]};

endmodule
