# -*- coding: utf-8 -*-
"""Dataset.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aEQUgn1EjOd6ldtPse79_5ItvZ8lyxvE
"""

pip install matplotlib

import numpy as np
import scipy.signal as signal
import matplotlib.pyplot as plt
import csv
import os

class BioSignalGenerator:
    """Bio Signal Generator"""

    def __init__(self, fs=1000, duration=10):
        self.fs = fs  # Sampling frequency (Hz)
        self.duration = duration  # Duration (seconds)
        self.t = np.linspace(0, duration, int(duration * fs))

    def generate_ecg(self, heart_rate=70, noise_level=0.1, channel_id=0):
        """Generate the ECG signal"""
        # Calculate R-R interval (with irregularity)
        mean_rr = 60.0 / heart_rate  # seconds
        rr_variation = 0.05  # 5% variation

        # Generate R-peak times
        num_beats = int(self.duration / mean_rr)
        rr_intervals = np.random.normal(mean_rr, rr_variation, num_beats)
        peak_times = np.cumsum(rr_intervals)
        peak_times = peak_times[peak_times < self.duration]

        # Initialize ECG waveform
        ecg = np.zeros_like(self.t)

        # Generate PQRST complex for each R-peak
        for peak_time in peak_times:
            # P wave (0.1 seconds before)
            p_center = peak_time - 0.15
            p_mask = (self.t >= p_center - 0.05) & (self.t <= p_center + 0.05)
            if np.any(p_mask):
                p_wave = 0.3 * signal.gausspulse(self.t[p_mask] - p_center, fc=8, bw=0.8)
                ecg[p_mask] += p_wave

            # QRS complex (main peak)
            qrs_mask = (self.t >= peak_time - 0.04) & (self.t <= peak_time + 0.04)
            if np.any(qrs_mask):
                qrs_wave = signal.gausspulse(self.t[qrs_mask] - peak_time, fc=20, bw=0.5)
                ecg[qrs_mask] += qrs_wave

            # T wave (0.2 seconds after)
            t_center = peak_time + 0.25
            t_mask = (self.t >= t_center - 0.1) & (self.t <= t_center + 0.1)
            if np.any(t_mask):
                t_wave = 0.4 * signal.gausspulse(self.t[t_mask] - t_center, fc=4, bw=1.2)
                ecg[t_mask] += t_wave

        # Add noise
        # 1. Gaussian white noise
        white_noise = np.random.normal(0, noise_level, len(self.t))

        # 2. 60Hz powerline interference
        powerline = 0.05 * np.sin(2 * np.pi * 60 * self.t)

        # 3. Baseline drift (breathing, movement)
        drift_freq = 0.5  # 0.5 Hz
        baseline_drift = 0.1 * np.sin(2 * np.pi * drift_freq * self.t)

        # 4. Muscle artifact (high frequency bursts)
        if channel_id % 4 == 0:  # Add to some channels only
            muscle_times = np.random.uniform(0, self.duration, 3)
            for mt in muscle_times:
                artifact_mask = (self.t >= mt) & (self.t <= mt + 0.5)
                if np.any(artifact_mask):
                    muscle_artifact = 0.2 * np.random.normal(0, 1, np.sum(artifact_mask))
                    white_noise[artifact_mask] += muscle_artifact

        final_ecg = ecg + white_noise + powerline + baseline_drift

        # 12-bit ADC simulation (0-4095)
        final_ecg = np.clip(final_ecg * 1000 + 2048, 0, 4095)

        return final_ecg.astype(np.int16), peak_times

    def generate_eeg(self, channel_id=0, noise_level=0.2):
        """Generate EEG signal (8-30Hz band)"""
        # Main EEG rhythms
        alpha_freq = 10  # 10Hz alpha wave
        beta_freq = 20   # 20Hz beta wave
        theta_freq = 6   # 6Hz theta wave

        # Basic EEG signal
        alpha_wave = 0.5 * np.sin(2 * np.pi * alpha_freq * self.t)
        beta_wave = 0.3 * np.sin(2 * np.pi * beta_freq * self.t)
        theta_wave = 0.4 * np.sin(2 * np.pi * theta_freq * self.t)

        # Channel-specific phase shift (spatial correlation)
        phase_shift = channel_id * np.pi / 8
        alpha_wave = 0.5 * np.sin(2 * np.pi * alpha_freq * self.t + phase_shift)

        # Epileptic spike simulation (some channels only)
        eeg = alpha_wave + beta_wave + theta_wave
        if channel_id < 4:  # Add spikes to first 4 channels only
            spike_times = np.random.uniform(2, 8, 2)  # 2-3 spike
            for spike_time in spike_times:
                spike_mask = (self.t >= spike_time) & (self.t <= spike_time + 0.1)
                if np.any(spike_mask):
                    spike = 2.0 * signal.gausspulse(self.t[spike_mask] - spike_time, fc=50)
                    eeg[spike_mask] += spike

        # Add noise
        noise = np.random.normal(0, noise_level, len(self.t))
        eeg += noise

        # ADC conversion
        eeg = np.clip(eeg * 800 + 2048, 0, 4095)
        return eeg.astype(np.int16)

    def generate_emg(self, muscle_activity=0.3, channel_id=0):
        """Generate EMG signal (electromyography)"""
        # Basic muscle activity (20-500Hz)
        emg = np.zeros_like(self.t)

        # Muscle contraction events
        contraction_times = np.random.uniform(0, self.duration, int(muscle_activity * 10))

        for ct in contraction_times:
            # Contraction duration (0.5-2 seconds)
            duration = np.random.uniform(0.5, 2.0)
            contraction_mask = (self.t >= ct) & (self.t <= ct + duration)

            if np.any(contraction_mask):
                # High-frequency muscle activity
                high_freq = np.random.uniform(100, 300)
                contraction_signal = np.random.normal(0, 0.5, np.sum(contraction_mask))

                # Signal envelope (gradual increase/decrease)
                envelope = np.hanning(np.sum(contraction_mask))
                contraction_signal *= envelope

                emg[contraction_mask] += contraction_signal

        # Background noise
        background_noise = np.random.normal(0, 0.1, len(self.t))
        emg += background_noise

        # ADC conversion
        emg = np.clip(emg * 1000 + 2048, 0, 4095)
        return emg.astype(np.int16)

    def generate_multi_channel_dataset(self, num_channels=16):
        """Generate multi-channel dataset"""
        datasets = {}

        print(f"Generating {num_channels}-channel biomedical signals...")

        for ch in range(num_channels):
            if ch < 6:  # ECG channels
                heart_rate = 60 + ch * 5  # 60-85 BPM
                noise = 0.05 + ch * 0.02
                signal_data, peaks = self.generate_ecg(heart_rate, noise, ch)
                signal_type = "ECG"

            elif ch < 12:  # EEG channels
                noise = 0.1 + (ch-6) * 0.03
                signal_data = self.generate_eeg(ch-6, noise)
                signal_type = "EEG"
                peaks = None

            else:  # EMG channels
                activity = 0.2 + (ch-12) * 0.1
                signal_data = self.generate_emg(activity, ch-12)
                signal_type = "EMG"
                peaks = None

            datasets[f"channel_{ch:02d}"] = {
                'data': signal_data,
                'type': signal_type,
                'sampling_rate': self.fs,
                'peaks': peaks
            }

            print(f"  Channel {ch:2d}: {signal_type} - "
                  f"Mean: {np.mean(signal_data):.1f}, "
                  f"Std: {np.std(signal_data):.1f}")

        return datasets

    def save_to_csv(self, datasets, output_dir="test_data"):
        os.makedirs(output_dir, exist_ok=True)

        for ch_name, ch_data in datasets.items():
            filename = f"{output_dir}/{ch_name}.csv"
            with open(filename, 'w') as f:
                for sample in ch_data['data']:
                    f.write(f"{sample:04X}\n")  # Hexadecimal format

        # Combined file (all channels)
        all_channels_file = f"{output_dir}/all_channels.csv"
        with open(all_channels_file, 'w', newline='') as f:
            writer = csv.writer(f)

            headers = [f"CH{i:02d}" for i in range(len(datasets))]
            writer.writerow(headers)

            max_length = max(len(data['data']) for data in datasets.values())
            for i in range(max_length):
                row = []
                for ch_name in sorted(datasets.keys()):
                    if i < len(datasets[ch_name]['data']):
                        row.append(f"{datasets[ch_name]['data'][i]:04X}")
                    else:
                        row.append("0000")
                writer.writerow(row)

        print(f"Data saved to {output_dir}/")
        return output_dir

    def create_test_scenarios(self):
        """Create various test scenarios"""
        scenarios = {
            'normal': {
                'description': 'Normal physiological signals',
                'duration': 10,
                'fs': 1000
            },
            'high_noise': {
                'description': 'High noise environment',
                'duration': 5,
                'fs': 1000,
                'noise_multiplier': 3
            },
            'stress_test': {
                'description': 'High sampling rate stress test',
                'duration': 2,
                'fs': 5000  # 5kHz sampling
            },
            'artifact_heavy': {
                'description': 'Heavy motion artifacts',
                'duration': 8,
                'fs': 1000,
                'artifact_level': 'high'
            }
        }

        for scenario_name, params in scenarios.items():
            print(f"\nGenerating scenario: {scenario_name}")

           # Apply scenario-specific parameters
            gen = BioSignalGenerator(
                fs=params.get('fs', 1000),
                duration=params.get('duration', 10)
            )

            datasets = gen.generate_multi_channel_dataset()

            output_dir = f"test_data/{scenario_name}"
            gen.save_to_csv(datasets, output_dir)

def main():
    """Main execution function"""
    print("Biomedical Signal Generator for HS-DAQ Controller")
    print("=" * 50)

    # Generate basic test data
    generator = BioSignalGenerator(fs=1000, duration=10)
    datasets = generator.generate_multi_channel_dataset(num_channels=16)

    output_dir = generator.save_to_csv(datasets)

    # Generate various scenarios
    generator.create_test_scenarios()

    # Simple plot generation (for verification)
    plt.figure(figsize=(12, 8))

    # ECG
    plt.subplot(3, 1, 1)
    plt.plot(generator.t[:1000], datasets['channel_00']['data'][:1000])
    plt.title('ECG Signal (Channel 0)')
    plt.ylabel('ADC Value')

    # EEG
    plt.subplot(3, 1, 2)
    plt.plot(generator.t[:1000], datasets['channel_06']['data'][:1000])
    plt.title('EEG Signal (Channel 6)')
    plt.ylabel('ADC Value')

    # EMG
    plt.subplot(3, 1, 3)
    plt.plot(generator.t[:1000], datasets['channel_12']['data'][:1000])
    plt.title('EMG Signal (Channel 12)')
    plt.xlabel('Time (s)')
    plt.ylabel('ADC Value')

    plt.tight_layout()
    plt.savefig(f"{output_dir}/sample_signals.png", dpi=150)
    plt.show()

    print(f"\nGeneration complete!")
    print(f"Check '{output_dir}' directory for generated files.")

if __name__ == "__main__":
    main()